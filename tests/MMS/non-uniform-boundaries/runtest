#!/usr/bin/env python3
import boutcore as bc
import numpy as np
import sys

#requires boutcore
#requires not make

bc.init("-d data -q -q -q")
doPlot=0
for f in sys.argv[1:]:
    if f == '-p':
        doPlot += 1

def mget(f):
    return f[3,:,0].flatten()

mmax=10
start=9

def plot(*args):
    import matplotlib.pyplot as plt
    def close_event():
        plt.close()
    fig=plt.figure()
    for f in args:
        pf = plt.plot
        if "log" in f:
            f.remove("log")
            pf=plt.loglog
        if isinstance(f[-1],str):
            pf(*f[:-1],label=f[-1])
        else:
            pf(*f)
        #plt.plot(mget(y),mget(f),'-o')
        #plt.plot(mget(y),fo,'x-')
        plt.legend()
    timer = fig.canvas.new_timer(interval = 4000)
    timer.add_callback(close_event)
    timer.start()
    plt.show()

def create(nx,low):
    udx=2*np.pi/nx
    if not low:
        ux=np.linspace(-1.5*udx,2*np.pi+1.5*udx,num=(nx+4))
    else:
        ux=np.linspace(-1*udx,2*np.pi+2*udx,num=(nx+4))
    nux = ux-.8*np.cos(ux)
    return nux

def integrate(dat,low):
    ret=np.zeros_like(dat)
    cur=-dat[0]
    cur-=dat[1]
    if low:
        for i in range(len(dat)):
            ret[i] = cur
            cur+=dat[i]
    else:
        for i in range(len(dat)):
            cur+=dat[i]/2
            ret[i] = cur
            cur+=dat[i]/2
    return ret


def test(bdry, func, loc):
    errs=[]
    dy=[]

    for ny in np.logspace(start,mmax,num=mmax-start+1,base=2):
        #try:
        #    mesh=mesh_cache[ny]
        #    y=y_cache[ny]
        #except KeyError:
        bc.setOption("mesh:ny","%d"%ny,force=True)
        bc.setOption("mesh:dy","(1+0.8*sin(y))/%d*2*pi"%ny,force=True)
        #y=
        mesh=bc.Mesh(section="mesh")
        #mesh_cache[ny]=mesh
        #y=bc.create3D("realy",mesh,outloc=loc)
        #    y_cache[ny]=y
        #y = create(ny,loc != "CENTRE") # assuming we are not staggering in the 
        mdy = mesh.coordinates.dy.get()[3,:].flatten()
        y=integrate(mdy,loc != "CENTRE")
        fd=func(y)
        f = bc.create3D("y",mesh,outloc=loc)
        fds= fd.reshape((1,int(ny)+4,1))
        for i in range(6):
            f[i,:,0] = fds

        fo=mget(f)
        #y=mget(y)
        opt=bc.Options("")

        myg=int(opt.get("mesh:myg",0))

        for i in range(myg):
            f[0, i  ,0]=-1
            f[0,-1-i,0]=-1

        f.applyBoundary(bdry)
        f=mget(f)
        #print(np.sum(mdy[2:-2])/np.pi,(y[-2]-y[1])/np.pi)
        #print(y/np.pi)
        if doPlot > 2:
            plot([y,f,"with bc"],[y,fo,"org"],[y,"numpy"],[integrate(mdy,loc != "CENTRE"),"bc"])
        #plot([y,f-fo])
        er=np.max(np.abs(f-fo))
        errs.append(er)
        dy.append(1./ny)

    #print(np.max(er))

    errc=np.log(errs[-2]/errs[-1])
    difc=np.log(dy[-2]/dy[-1])
    #print(dy)
    #print(errs)
    conv=errc/difc
    success= order - .25 < conv < order + .25
    if doPlot > 1 or (not success and doPlot > 0):
        plot([dy,errs,"log","error vs spacing"])
    #print(conv)
    if success:
        return 0
    else:
        print("Failure: %s %s %s - expected %d, got %g"%(bdry,func,loc,order,conv))
        return 1



testdata=[
    ["dirichlet_nu_o4", np.sin, 5],
    ["dirichlet_nu_o3", np.sin, 3],
    ["dirichlet_nu_o2", np.sin, 3],
    ["neumann_nu_o2", np.cos,2],
    ["neumann_nu_o3", np.cos,[5,2]],
    ["neumann_nu_o4", np.cos,[4,2]],
    ["free_nu_o2", np.cos,2],
    ["free_nu_o3", np.cos,[4,2]],
    ["free_nu_o4", np.cos,[4,2]],
    ["free_nu_o2", np.sin,[3,1]],
    ["free_nu_o3", np.sin,[3,1]],
    ["free_nu_o4", np.sin,[5,1]]
]

code=0
locs=["CENTRE", "YLOW" ]
for bdry, func, forder in testdata:
    for loc in locs:#"XLOW", "YLOW", "ZLOW"]:
        if isinstance(forder,list):
            order=forder[locs.index(loc)]
        else:
            order=forder
        code += test(bdry, func, loc)

sys.exit(code)
