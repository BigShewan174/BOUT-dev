#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Run the test suite, report failures
#
# To set command for running parallel jobs, define environment variable
# e.g. for bash
# export MPIRUN="mpirun -np"
# export MPIRUN="aprun -n"

from __future__ import print_function
import os
import sys
import time
import glob
from boututils.run_wrapper import shell
import threading
import re
import fcntl

##################################################################

import argparse
parser = argparse.ArgumentParser(description='Run or build some tests.')
parser.add_argument("-g", "--get-list", action='store_true',
                    help='Return a list of tests that would be run/build')
parser.add_argument("-m", "--make", action='store_true',
                    help='Build the tests, rather then run them.')
parser.add_argument("-a", "--all", action='store_true', dest="all_tests",
                    help="Run all tests")
parser.add_argument("-b", "--set-bool", nargs="+", metavar=('value1=False', 'value2=True'),
                    help='Set a bool value for evaluating what scripts can be run.')
parser.add_argument("-l", "--set-list", nargs="+", metavar=('test1', 'test2'),
                    help='Set the tests that should be run.')
parser.add_argument("-j", "--jobs", nargs=1, type=int, dest='jobs',
                    help='Set the number of cores to use in parallel.')

args = parser.parse_args()

##################################################################

sys.path.append('..')
from requirements import Requirements
requirements = Requirements()

if args.set_bool is not None:
    lookup = {'false': False,
              'no': False,
              'true': True,
              'yes': True}
    for setbool in args.set_bool:
        k, v = setbool.split("=")
        v = lookup[v.lower()]
        requirements.add(k, v, override=True)

try:
    requirements.add('make', args.make)
except RuntimeError:
    raise RuntimeError("The make flag needs to be set by passing --make rather then --set-bool make=True")

try:
    requirements.add('all_tests', args.all_tests)
except RuntimeError:
    raise RuntimeError("The all-tests flag needs to be set by passing --all rather then --set-bool all_tests=True")

##################################################################
# Parallel stuff

# Check what we are supposed to be doing:
if 'MAKEFLAGS' in os.environ:
    mf=os.environ['MAKEFLAGS']
    for token in mf:
        if token == "n":
            # Print recipies:
            # We ignore this for now ...
            sys.exit(0)
        elif token == "q":
            # Question mode:
            # We are never up-to-date
            sys.exit(1)
        elif token in "ksBd":
            # k - keep going
            # s - silent
            # B - always build (we do)
            # d - debug
            pass
        elif token == " ":
            break
        elif token == "-":
            # This is not from make
            break
        else:
            # Not implemented
            print("mode '%s' not implemented"%token)
            #sys.exit(42)
else:
    mf = ""

num_jobs=1
if args.jobs:
    num_jobs = args.jobs[0]
js_read=None
if "--jobserver-auth=" in mf or "--jobserver-fds=" in mf:
    # running in parallel
    try:
        offset=mf.index("--jobserver-auth=")
    except ValueError:
        offset=mf.index("--jobserver-fds=")
    file_desc=[int(i) for i in re.findall("\d+",mf[offset:])[0:2]]
    js_read = file_desc[0]
    js_write = file_desc[1]
    #try:
    #    js_read = os.open(file_desc[0], "r")
    #    js_write = os.open(file_desc[1], "w")
    #except:
    #    print("Warning - we are not part of the job pool 😭, running in serial")
    #    raise
    #    file_desc = None
    #    js_read = None
    if js_read is not None:
        fl = fcntl.fcntl(js_read, fcntl.F_GETFL)
        fcntl.fcntl(js_read, fcntl.F_SETFL, fl | os.O_NONBLOCK)

class Test(threading.Thread):
    def __init__(self, name, cmd):
        threading.Thread.__init__(self)
        self.name = name
        self.cmd = cmd
        self.l = threading.local()
        self.cost = self._cost()
    def run(self):
        # Check requirements
        self.l.req_met, self.l.req_expr = requirements.check(self.name+"/runtest")
        self.l.start_time = time.time()
        if not self.l.req_met:
            print(output % self.name +
                  "S - {0} => False".format(self.l.req_expr))
            sys.stdout.flush()
            self.status = 0
        else:
            # Run test, piping stdout so it is not sent to console
            self.status, self.output = shell("cd "+self.name+";"+self.cmd, pipe=True)
            print(output % self.name, end='')
            if self.status != 0:
                # ❌ Failed
                print(u"\u274C", end='')  # No newline
            else:
                # ✓ Passed
                print(u"\u2713", end='')  # No newline
            print(" %7.3f s" % (time.time() - self.l.start_time))
            sys.stdout.flush()  # Make sure '✓' or '❌' is flushed
    def _cost(self):
        if self.cmd == "make":
            return 1
        with open(self.name+"/"+self.cmd,"r") as filein:
            contents = filein.read()
            # Find all lines starting with '#requires' or '#Requires:'
            match = re.findall(
                "^\s*\#\s?[Cc]ores:\s*?(\d+)", contents, re.MULTILINE)
            if len(match) > 1:
                raise RuntimeError("Found more then one match for core-count in "+self.name)
            if len(match) == 0:
                # default; no mpi
                return 1
            c = int(match[0])
            if not c > 0:
                raise RuntimeError("Core-count is %d and thus not positive in "%c+self.name)
            return c

##################################################################

if args.set_list is None:
    # Get list of directories containing test cases
    try:
        # Requires python >= 3.5
        tests = glob.iglob('**/runtest', recursive=True)
    except TypeError:
        # Fall back - check only a few folders ...
        tests = glob.glob('*/runtest')
        tests += glob.glob('*/*/runtest')
        tests += glob.glob('*/*/*/runtest')

    tests = [x.rsplit('/', 1)[0] for x in tests]

else:
    # Take the user provided list
    tests = [x.rstrip('/') for x in args.set_list]


if args.get_list:
    for test in tests:
        req_met, _ = requirements.check(test+"/runtest")
        if req_met:
            print(test)
    sys.exit(0)

##################################################################
# Run the actual test

command = './runtest' if not args.make else 'make'

savepath = os.getcwd()  # Save current working directory
failed = []

start_time = time.time()

test_type = "Making" if args.make else "Running"

print("======= {} {} {} tests ========".format(test_type, len(tests), savepath.split("/")[-1]))

avail = num_jobs
tester = sorted([Test(t, command) for t in tests],
                key=lambda x: x.cost, reverse=True)
cost_remain = sum(x.cost for x in tester)
if js_read:
    js_tokens = os.read(js_read,cost_remain-1)
    num_jobs = len(js_tokens)+1

torun=[i for i in range(len(tests))]
running=[]

longest = max([len(s) for s in tests])
output = '%-'+str(longest+1)+'s'

while len(torun)+len(running):
    if avail:
        # See whether we can start one
        for i in torun:
            if tester[i].cost <= avail:
                torun.remove(i)
                job = tester[i]
                job.start()
                running.append(job)
                avail -= job.cost
                cost_remain -= job.cost
        # if nothing is running, start the first
        if running == []:
            tostart = torun.pop(0)
            job = tester[tostart]
            job.start()
            running.append(job)
            avail -= job.cost
            cost_remain -= job.cost

    # Are any jobs finished
    for job in running:
        job.join(.1)
        if not job.is_alive():
            if job.status:
                failed.append([job.name,job.output])
            avail += job.cost
            running.remove(job)

    # Try to get more jobs
    if torun:
        if js_read is not None:
            try:
                newt = os.read(js_read,cost_remain)
            except BlockingIOError:
                newt = ""
            if newt != "":
                js_tokens += newt
                avail += len(newt)
                num_jobs += len(newt)
    else:
        # Free not-needed jobs
        if avail:
            if js_read:
                newt = js_tokens[0:avail]
                js_tokens = js_tokens[avail:]
                os.write(js_write,newt)
                num_jobs -= avail
                avail = 0


elapsed_time = time.time() - start_time

print("\n")

# Return remaining tokens
if js_read is not None:
    if js_tokens != "":
        js_write.write(t)

if failed:
    print("======= FAILURES ========")
    for test, output in failed:
        # Note: need Unicode string in case output contains unicode
        print(u"\n----- {0} -----\n{1}".format(test, output))

    print("======= {0} failed in {1:.2f} seconds ========".format(
        len(failed), elapsed_time))

    sys.exit(1)

else:
    print("======= All tests passed in {0:.2f} seconds =======".format(
        elapsed_time))
